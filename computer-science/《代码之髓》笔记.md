>来自 2018-03-26 的读书笔记，这本书很薄，这是读第二遍，每次读都有新收获。
应该找时间再读一遍，把这篇笔记也好好写写。。。

1. 函数：过程抽象
1. 嵌套数据结构的遍历 - 递归
1. 异常处理
    1. try catch
    1. 成对操作的无遗漏执行
        1. finally 语句
        1. 资源自动管理：py 的 with，java 的 try-with-resources
    1. 是否应该在方法上标明可能抛出的异常？是否需要 受查/检查型 异常？
        - 回答：理念很棒，但 java 的实现方式，使得使用起来很繁琐。如果有更好的实现就好了。
    1. 使用异常，还一返回错误值？
        - 如果该错误是出人意料的，就用异常；反之，如果在某种程度上它是在预计范围内的，就应该使用错误值。
1. 变量、作用域
1. 容器：数组、链表、map、树、栈、队列
1. 字符编码：内部编码、输出编码、源文件的编码
1. 并发、并行
    1. amdal定律：并行加速比
    1. 竞态条件、不安全的前提
        1. 两个处理 共享内存
        1. 至少一个处理 会修改变量
        1. 变量的修改操作不具有原子性
    1. 消除竞态条件的方法：
        1. 不共享内存：进程
        1. 不可变对象
        1. 同步：同一时间只能有一个处理接触该变量。
            - 锁(实际上只是一个表示 '使用中' 的状态牌，其他处理也需要检查它，才能发挥效用)
        1. 保证修改操作的原子性：atomic
    1. 死锁的对策：事务管理，失败回滚
    1. 线程池
    1. 进程间通信：MessageQueue
1. 面向对象
    1. 类、对象
    1 . 多继承的缺点，与其替代方案：委托（依赖注入）、接口、trait
1. 内存管理 GC
1. 大数据：
    1. 存储
        1. 传统 SQL 的 性能局限（ACID），与 NoSQL 的 BASE 模型。
        1. redis 缓存：数据的访问具有局部性
    1. map reduce：分布式处理
    1. 并发量：C10K 问题
并发量：C10K 问题
1. IO
    1. 非阻塞IO：Java 的 NIO
    1. 异步IO：Python 的 asyncio